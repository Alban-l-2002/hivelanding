<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Connected Hexes â€” Side-Joined (Black + White)</title>
<style>
  :root { --bg: #000; --fg: #fff; --fg-dim: rgba(255,255,255,.85); }
  html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); }
  /* Subtle vignette without changing layout */
  body { background: radial-gradient(120% 80% at 50% 45%, #0b0b0b 0%, #000 60%, #000 100%); }
  .stage { min-height: 100%; display: grid; place-items: center; }
  svg { width: min(92vmin, 900px); height: auto; overflow: visible; shape-rendering: geometricPrecision; text-rendering: optimizeLegibility; }

  /* Outlines (JS-driven) */
  .hex {
    fill: none;
    stroke: var(--fg);
    stroke-width: 0.8;
    vector-effect: non-scaling-stroke;
    stroke-linejoin: round;
    stroke-linecap: round;
    filter: url(#glow);
    pointer-events: none; /* don't block dot hover at vertices */
  }

  /* Corner dots (animated via JS) */
  .dot {
    fill: var(--fg);
    filter: url(#dotGlow);
    opacity: 0;
    transform-box: fill-box;
    transform-origin: 50% 50%;
    transform: scale(.7);
    pointer-events: none; /* enabled post-animation for target only */
  }

  /* Post-animation interactivity for the 6 target dots */
  .dot.interactive {
    pointer-events: auto;
    cursor: pointer;
    will-change: transform, filter, opacity;
    transition: transform 160ms cubic-bezier(.2,.6,.2,1) !important,
                opacity 140ms ease !important,
                filter 160ms ease !important;
    outline: none;
    -webkit-tap-highlight-color: transparent;
  }
  .dot.interactive:hover, .dot.interactive:focus-visible { transform: scale(10); opacity: 1; filter: url(#dotGlowUltra); }
  .dot.interactive:active { transform: scale(9.4); }

  /* Ripple ring created on hover/focus (non-blocking) */
  .ring { fill: none; stroke: var(--fg-dim); stroke-width: 0.8; opacity: 0; pointer-events: none; vector-effect: non-scaling-stroke; }

  /* Transient connecting lines between hex centres (fade out + remove) */
  .edge {
    stroke: var(--fg);
    stroke-width: 0.6;
    opacity: 0;                 /* start hidden; JS toggles */
    vector-effect: non-scaling-stroke;
    stroke-linecap: round;
  }

  /* Reduced motion: render final state instantly */
  @media (prefers-reduced-motion: reduce) {
    .hex, .dot, .edge, .ring { transition: none !important; opacity: 1 !important; transform: none !important; filter: none !important; }
  }
  /* Remove default focus rectangle for SVG elements */
  svg :focus, svg :focus-visible { outline: none; }
  svg [tabindex]:focus { outline: none; }
  svg { -webkit-tap-highlight-color: transparent; }
</style>
</head>
<body>
  <main class="stage" aria-label="Cluster of hexagons joined by their sides, with radial fading, white on black">
    <svg viewBox="0 0 600 420" role="img" aria-label="Side-joined hex cluster with radial fade" focusable="false">
      <defs>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur in="SourceGraphic" stdDeviation="0.8" result="b" />
          <feMerge>
            <feMergeNode in="b"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>

        <!-- slightly stronger glow for points -->
        <filter id="dotGlow" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur in="SourceGraphic" stdDeviation="1.6" result="b" />
          <feMerge>
            <feMergeNode in="b"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>

        <!-- stronger hover glow for points -->
        <filter id="dotGlowStrong" x="-80%" y="-80%" width="260%" height="260%">
          <feGaussianBlur in="SourceGraphic" stdDeviation="7.2" result="b1" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="2.8" result="b2" />
          <feMerge>
            <feMergeNode in="b1"/>
            <feMergeNode in="b2"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>

        <!-- ultra hover glow for points (for 10x scale without clipping) -->
        <filter id="dotGlowUltra" x="-140%" y="-140%" width="380%" height="380%">
          <feGaussianBlur in="SourceGraphic" stdDeviation="12" result="b1" />
          <feGaussianBlur in="SourceGraphic" stdDeviation="4" result="b2" />
          <feMerge>
            <feMergeNode in="b1"/>
            <feMergeNode in="b2"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>

        <!-- Invisible radial mask (elliptical) for distance fade -->
        <radialGradient id="fadeGradient" gradientUnits="userSpaceOnUse" cx="300" cy="210" r="220" gradientTransform="translate(300 210) scale(1 0.7) translate(-300 -210)">
          <stop offset="0%"  stop-color="#fff" stop-opacity="1"/>
          <stop offset="35%" stop-color="#fff" stop-opacity="1"/>
          <stop offset="100%" stop-color="#000" stop-opacity="0"/>
        </radialGradient>
        <mask id="fadeMask" maskUnits="userSpaceOnUse" x="0" y="0" width="600" height="420">
          <rect x="0" y="0" width="600" height="420" fill="url(#fadeGradient)"/>
        </mask>
      </defs>

      <!-- Apply the radial fade to the whole cluster -->
      <g id="cluster" mask="url(#fadeMask)" transform="translate(300 210) scale(2) translate(-300 -210)"></g>

      <script>
        (function() {
          const svgNS = 'http://www.w3.org/2000/svg';
          const g = document.getElementById('cluster');

          const scale = (() => {
            const tr = g.getAttribute('transform') || '';
            const m = tr.match(/scale\(([^)]+)\)/);
            return m ? parseFloat(m[1]) : 1;
          })();

          const R = 50;                       // hex radius (flat-top side length)
          const ORIGIN = { x: 220, y: 180 };  // starting centre
          const SQ3 = Math.sqrt(3);

          // Helpers -----------------------------------------------------------
          const addRAF = fn => requestAnimationFrame(() => requestAnimationFrame(fn));
          const reduceMotion = matchMedia('(prefers-reduced-motion: reduce)').matches;

          // Axial -> pixel mapping for FLAT-TOP hexes (tiles touch by SIDES)
          const axialToPixel = (q, r) => ({
            x: ORIGIN.x + R * (1.5 * q),
            y: ORIGIN.y + R * (SQ3 * (r + q/2))
          });

          // Corner of a flat-top hex (0..5)
          const corner = (cx, cy, i) => {
            const angle = Math.PI / 180 * (60 * i);
            return [ cx + R * Math.cos(angle), cy + R * Math.sin(angle) ];
          };

          const hexPoints = (cx, cy) => {
            const pts = [];
            for (let i = 0; i < 6; i++) pts.push(corner(cx, cy, i));
            return pts;
          };

          const perimeter = (pts) => {
            let L = 0;
            for (let i = 0; i < pts.length; i++) {
              const a = pts[i];
              const b = pts[(i+1) % pts.length];
              L += Math.hypot(b[0]-a[0], b[1]-a[1]);
            }
            return L;
          };

          // Drawing primitives ------------------------------------------------
          function ripple(x, y, maxR = 28, dur = 420) {
            if (reduceMotion) return;
            const r = document.createElementNS(svgNS, 'circle');
            r.setAttribute('class', 'ring');
            r.setAttribute('cx', x); r.setAttribute('cy', y);
            r.setAttribute('r', 2);
            r.style.transition = `r ${dur}ms cubic-bezier(.22,.61,.36,1), opacity ${dur}ms ease`;
            g.appendChild(r);
            requestAnimationFrame(() => {
              r.style.opacity = '0.85';
              r.setAttribute('r', String(maxR));
              r.style.opacity = '0';
            });
            setTimeout(() => r.remove(), dur + 60);
          }

          function connect(x1, y1, x2, y2, delay = 0, draw = 520, hold = 260, fade = 220) {
            const l = document.createElementNS(svgNS, 'line');
            l.setAttribute('class', 'edge');
            l.setAttribute('x1', x1); l.setAttribute('y1', y1);
            l.setAttribute('x2', x2); l.setAttribute('y2', y2);
            const len = Math.hypot(x2 - x1, y2 - y1) * scale;
            l.style.strokeDasharray = String(len);
            l.style.strokeDashoffset = String(len);
            l.style.transition = `stroke-dashoffset ${draw}ms cubic-bezier(.2,.6,.2,1) ${delay}ms`;
            g.appendChild(l);

            // Make it visible immediately (so you don't see ghost lines later)
            l.style.opacity = '0.45';

            if (reduceMotion) {
              l.style.strokeDashoffset = '0';
              // quick fade + remove
              setTimeout(() => { l.remove(); }, Math.max(1, draw));
              return l;
            }

            // Animate draw
            addRAF(() => addRAF(() => { l.style.strokeDashoffset = '0'; }));

            // Fade out after draw+hold, then remove to avoid background lines
            const ttl = delay + draw + hold;
            setTimeout(() => {
              l.style.transition = `opacity ${fade}ms ease`;
              l.style.opacity = '0';
              setTimeout(() => l.remove(), fade + 40);
            }, ttl);
            return l;
          }

          function hex(cx, cy, delay = 0, dur = 520) {
            const pts = hexPoints(cx, cy);
            const poly = document.createElementNS(svgNS, 'polygon');
            poly.setAttribute('class', 'hex');
            poly.setAttribute('points', pts.map(p => p.join(',')).join(' '));
            const L = perimeter(pts) * scale;
            poly.style.strokeDasharray = String(L);
            poly.style.strokeDashoffset = String(L);
            poly.style.transition = `stroke-dashoffset ${dur}ms cubic-bezier(.2,.6,.2,1) ${delay}ms`;
            g.appendChild(poly);

            if (reduceMotion) {
              poly.style.strokeDashoffset = '0';
            } else {
              addRAF(() => addRAF(() => { poly.style.strokeDashoffset = '0'; }));
            }
            return { poly, pts };
          }

          function dots(pts, delay = 0, dur = 220) {
            const circles = [];
            pts.forEach((p, i) => {
              const c = document.createElementNS(svgNS, 'circle');
              c.setAttribute('class', 'dot');
              c.setAttribute('cx', p[0]);
              c.setAttribute('cy', p[1]);
              c.setAttribute('r', 2.0);
              c.style.transition = `opacity ${dur}ms ease ${delay + i*20}ms, transform ${dur}ms cubic-bezier(.2,.6,.2,1) ${delay + i*20}ms`;
              g.appendChild(c);
              if (reduceMotion) {
                c.style.opacity = '1';
                c.style.transform = 'scale(1)';
              } else {
                addRAF(() => addRAF(() => { c.style.opacity = '1'; c.style.transform = 'scale(1)'; }));
              }
              circles.push(c);
            });
            return circles;
          }

          // Layout ------------------------------------------------------------
          const core = [
            { q: 0, r: 0 },   // base (root)
            { q: 1, r: 0 },   // right of base (target for interactivity)
            { q: 2, r: 0 },   // further right
            { q: 1, r: -1 }   // upper-right touching the middle
          ];

          const extras = [
            { q: -1, r: 0 },
            { q: 3,  r: 0 },
            { q: 0,  r: -1 },
            { q: 2,  r: -1 }
          ];

          const below = [
            { q: 0, r: 1 },
            { q: 1, r: 1 },
            { q: 2, r: 1 }
          ];

          const cells = [...core, ...extras, ...below];

          // Index by axial key and centres
          const key = (q,r) => `${q},${r}`;
          const cellSet = new Set(cells.map(c => key(c.q,c.r)));
          const centres = new Map();
          cells.forEach(c => { centres.set(key(c.q,c.r), axialToPixel(c.q, c.r)); });

          // Axial neighbour deltas for flat-top (all 6)
          const NEI6 = [ [1,0], [1,-1], [0,-1], [-1,0], [-1,1], [0,1] ];
          // Unique undirected directions to avoid duplicates
          const UNI3 = [ [1,0], [1,-1], [0,-1] ];

          // BFS tree (parent -> child) starting from root (0,0)
          const rootKey = key(0,0);
          // bottom-right neighbour of the root (flat-top axial): (1,0)
          const targetKey = key(1,0);
          let targetDots = null;
          const visited = new Set([rootKey]);
          const queue = [rootKey];
          const treeEdges = []; // [parentKey, childKey]
          const treeEdgeSet = new Set();
          const level = new Map([[rootKey, 0]]);

          while (queue.length) {
            const pk = queue.shift();
            const [pq, pr] = pk.split(',').map(Number);
            NEI6.forEach(([dq, dr]) => {
              const nq = pq + dq, nr = pr + dr, nk = key(nq,nr);
              if (cellSet.has(nk) && !visited.has(nk)) {
                visited.add(nk);
                queue.push(nk);
                level.set(nk, (level.get(pk)||0) + 1);
                treeEdges.push([pk, nk]);
                // undirected key
                const ek = [pk, nk].sort().join('>');
                treeEdgeSet.add(ek);
              }
            });
          }

          // All neighbour connections (ensure every adjacent pair is present)
          const allEdges = [];
          cells.forEach(({q,r}) => {
            UNI3.forEach(([dq,dr]) => {
              const a = key(q,r), b = key(q+dq, r+dr);
              if (cellSet.has(b)) allEdges.push([a,b]);
            });
          });

          // Extra edges not in the tree (for full connectivity)
          const extraEdges = allEdges.filter(([a,b]) => !treeEdgeSet.has([a,b].sort().join('>')));

          // --- Timeline ------------------------------------------------------
          let t = 80;
          let maxEnd = 0; // track when everything finishes
          const revealAt = new Map();

          // Root: vertices then outline
          const rootC = centres.get(rootKey);
          const rootPts = hexPoints(rootC.x, rootC.y);
          const t0 = t;
          const rootDots = dots(rootPts, t, 240); // vertices first
          const rootDotsEnd = t0 + 100 + 240;     // last of 6 dots (i*20 => 100)
          maxEnd = Math.max(maxEnd, rootDotsEnd);
          t += 120;

          hex(rootC.x, rootC.y, t, 520);         // draw root outline
          const rootHexEnd = t + 520;
          maxEnd = Math.max(maxEnd, rootHexEnd);
          revealAt.set(rootKey, t);
          t += 180;

          // Animate tree edges outward (guarantees every node appears)
          treeEdges.forEach(([pk, ck]) => {
            const start = t;
            const p = centres.get(pk);
            const c = centres.get(ck);
            connect(p.x, p.y, c.x, c.y, start, 520, 280, 220); // draw -> hold -> fade
            const connectEnd = start + 520 + 280 + 220;
            maxEnd = Math.max(maxEnd, connectEnd);

            hex(c.x, c.y, start + 220, 520); // child outline
            const hexEnd = start + 220 + 520;
            maxEnd = Math.max(maxEnd, hexEnd);

            const cPts = hexPoints(c.x, c.y);
            const created = dots(cPts, start + 260, 220);
            if (ck === targetKey) targetDots = created; // capture target dots
            const childDotsEnd = start + 260 + 100 + 220;
            maxEnd = Math.max(maxEnd, childDotsEnd);

            revealAt.set(ck, start + 220);
            t += 200; // advance timeline
          });

          // After nodes are in, add remaining neighbour links, then fade them
          extraEdges.forEach(([a,b]) => {
            const A = centres.get(a), B = centres.get(b);
            const dly = Math.max(revealAt.get(a) || 0, revealAt.get(b) || 0) + 240;
            connect(A.x, A.y, B.x, B.y, dly, 420, 160, 200);
            const extraEnd = dly + 420 + 160 + 200;
            maxEnd = Math.max(maxEnd, extraEnd);
          });

          // Enable hover on the 6 vertices of the bottom-right neighbour (q=1,r=0) *after* all animations complete
          setTimeout(() => {
            (targetDots || []).forEach(d => {
              d.classList.add('interactive');
              
              d.setAttribute('role','button');
              d.setAttribute('aria-label','Hex vertex');
              const x = +d.getAttribute('cx');
              const y = +d.getAttribute('cy');
              const trigger = () => ripple(x, y, 32, 480);
              d.addEventListener('mouseenter', trigger);
              d.addEventListener('focus', trigger);
                          });
          }, reduceMotion ? 0 : (maxEnd + 60));

          // ------------------- Minimal Runtime Tests (Console) -----------------
          // We log results to the console without changing the layout.
          function assert(name, condition) {
            if (condition) { console.log(`%cPASS%c ${name}`, 'color:#00c853;font-weight:700', ''); }
            else { console.error(`%cFAIL%c ${name}`, 'color:#d50000;font-weight:700', ''); }
          }

          // Run tests shortly after interactivity is enabled
          setTimeout(() => {
            try {
              const interactive = Array.from(g.querySelectorAll('circle.dot.interactive'));
              assert('Exactly 6 interactive dots exist', interactive.length === 6);

              // Check there are no lingering edge lines (should be faded & removed)
              const edgesLeft = g.querySelectorAll('line.edge').length;
              assert('No transient edges remain', edgesLeft === 0);

              // Trigger a ripple programmatically and ensure a ring appears then disappears
              if (interactive[0]) {
                const x = +interactive[0].getAttribute('cx');
                const y = +interactive[0].getAttribute('cy');
                ripple(x, y, 30, 300);
                const hadRing = g.querySelectorAll('circle.ring').length > 0;
                setTimeout(() => {
                  const ringsAfter = g.querySelectorAll('circle.ring').length;
                  assert('Ripple ring appended and later removed', hadRing && ringsAfter === 0);
                }, 600);
              }
            } catch (e) {
              console.error('Test harness error:', e);
            }
          }, reduceMotion ? 100 : (maxEnd + 400));
        })();
      </script>
    </svg>
  </main>
</body>
</html>